<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009" 
		 xmlns:s="library://ns.adobe.com/flex/spark" 
		 xmlns:mx="library://ns.adobe.com/flex/mx" color="#ffffff">
	<fx:Script>
		<![CDATA[
			import mx.events.FlexEvent;
			import mx.graphics.BitmapSmoothingQuality;
			import mx.graphics.codec.JPEGEncoder;
			import mx.messaging.channels.StreamingAMFChannel;
			import mx.utils.Base64Decoder;
			import mx.utils.Base64Encoder;
			
			import org.springextensions.actionscript.ioc.config.impl.xml.namespacehandler.INamespaceHandler;
			
			import spark.filters.DropShadowFilter;
			
			private var inBytes:ByteArray = new ByteArray(); 
			
			[Bindable]private var nome:String;
			[Bindable]private var lvl:Number;
			[Bindable]private var race:String;
			[Bindable]private var location:String;
			[Bindable]private var sex:String;
			[Bindable]private var currentExp:Number;
			[Bindable]private var nextLevExp:Number;
			private var myShadow:spark.filters.DropShadowFilter = new DropShadowFilter();
			[Bindable]private var shadow:Array = [myShadow]
				
			public function readFileIntoByteArray(fileName:String):void 
			{ 
				trace("start loaded" + fileName)
				var inFile:File = new File(fileName) // source folder is desktop 
				//inFile = inFile.resolvePath("Salva.ess");  // name of file to read 
				var inStream:FileStream = new FileStream();
				
				inStream.open(inFile, FileMode.READ); 
				inStream.readBytes(inBytes); 
				trace("done")
				inStream.close();
				
				loaded2()
			} 
			protected function loaded2():void
			{
				try
				{
				var w:int;
				var h:int;
				var l:uint;
				var tmpArr:ByteArray = new ByteArray()
				var ni:int;
				inBytes.endian = Endian.LITTLE_ENDIAN
				trace(inBytes.readUTFBytes(13))
				trace('1',inBytes.position)
				
				trace(inBytes.readInt())
				trace('2',inBytes.position)
				trace(inBytes.readInt())
				trace('3',inBytes.position)
				trace(inBytes.readInt())
				trace('4',inBytes.position)
				trace(ni = inBytes.readShort())
				trace('5',inBytes.position)
				nome = inBytes.readUTFBytes(ni)
				trace('6',inBytes.position)
				lvl = inBytes.readInt();
				trace('7',inBytes.position);
				trace(ni = inBytes.readShort())
				trace('8',inBytes.position);
				location = inBytes.readUTFBytes(ni)
				trace('9',inBytes.position);
				trace(ni = inBytes.readShort())
				trace('10',inBytes.position);
				trace(inBytes.readUTFBytes(ni))
				trace('11',inBytes.position);
				trace(ni = inBytes.readShort())
				trace('12',inBytes.position);
				race = inBytes.readUTFBytes(ni)
				trace('13',inBytes.position);
				sex = inBytes.readShort().toString()
				trace('14',inBytes.position);
				currentExp = inBytes.readFloat()
				trace('15',inBytes.position);
				nextLevExp = inBytes.readFloat()
				trace('16',inBytes.position);
				trace(inBytes.readDouble())
				trace('17',inBytes.position);
				trace(w = inBytes.readInt())
				trace('18',inBytes.position);
				trace(h = inBytes.readInt())
				trace('19',inBytes.position);
				/* trace(inBytes.readInt())
				trace('20',inBytes.position);
				trace(inBytes.readByte())
				trace('21',inBytes.position); */
				l = 3*w*h
				if(currentExp>nextLevExp)
					currentExp=100
				else
				currentExp = (currentExp*100)/nextLevExp
				
				var bitmapData:BitmapData;
				var bitmapBA:ByteArray = new ByteArray();
				var bitmap:Bitmap;
				//bitmapBA.endian = Endian.LITTLE_ENDIAN
				inBytes.readBytes(bitmapBA,0,l)
				
				trace('20',inBytes.position);
				trace(inBytes.readByte())
				trace('21',inBytes.position);
				bitmapData = new BitmapData(w, h);
				bitmapBA.position = 0
				bitmapBA.endian = Endian.LITTLE_ENDIAN
				
				for(var i:Number =0; i<h; i++)
				{
					for(var j:Number =0; j<w; j++)
					{
						var alphaValue = 0
						var redValue = bitmapBA.readByte();
						var greenValue = bitmapBA.readByte();
						var blueValue = bitmapBA.readByte();
						var color:uint = alphaValue << 32 | redValue << 16 | greenValue << 8 | blueValue;
						bitmapData.setPixel(j,i,color);
						//bitmapData.setPixel32(j,i, color);
					}
				}
				
				bitmapData.lock()
				// set the pixels of a bitmap from the loaded bitmapdata bytearray
				
				
				var bit:Bitmap = new Bitmap(bitmapData)
				
				
				bi.source = bit
				bi.smoothingQuality = BitmapSmoothingQuality.HIGH
				bi.smooth = true
				
				var myShadow:spark.filters.DropShadowFilter = new DropShadowFilter();
				

				//myGlow.color = 0xFFFFFF
				this.dati.filters = [myShadow]
				}
				catch(err:Error)
				{
					trace(err.message)
				}
			}
		]]>
	</fx:Script>
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>
	
	<s:VGroup id="dati" verticalAlign="middle" left="10" >
		<s:BitmapImage  id="bi" width="180" height="108" scaleMode="zoom" />
		<s:HGroup >
			<s:Label text="Name:"  />
			<s:Label fontFamily="MorrisRomanBlack" text="{nome}" fontSize="18"/>
		</s:HGroup>
		<s:HGroup verticalAlign="middle">
			<s:Label text="Level:"  />
			<s:Label fontFamily="MorrisRomanBlack" text="{lvl}" fontSize="18" />
			<s:Group verticalCenter="0">
			<s:Line id="lineabg" xFrom="{0}" xTo="{101}" yFrom="0" yTo="0">

				<s:stroke>
					<s:SolidColorStroke color="0x000000" weight="10" caps="round"/>
				</s:stroke>
			</s:Line>
			<s:Line id="linea" xFrom="{1}" xTo="{currentExp}" yFrom="0" yTo="0">
				
				<s:stroke>
					<s:SolidColorStroke color="#00ccff" weight="5" caps="round"/>
				</s:stroke>
			</s:Line>
				
			</s:Group>
			
		</s:HGroup>
		<s:HGroup >
			<s:Label text="Race:"  />
			<s:Label fontFamily="MorrisRomanBlack" text="{race}" fontSize="18"/>
		</s:HGroup>
		<s:HGroup >
			<s:Label text="Location:"  />
			<s:Label fontFamily="MorrisRomanBlack" text="{location}" fontSize="18"/>
		</s:HGroup>
	</s:VGroup>
</s:Group>
